---
title: "How to make a custom home voice personal assistant based on an esp32"
date: 2024-08-06T18:39:07+01:00
draft: true
author: Romain MELLAZA
cover: 'https://romainmellaza.fr/img/cristal-home-assistant/pres1.jpg'
tags: ["Electronic", "C++", "esp32"]
theme: "light"
---

# Introduction 
This personal project is based on a simple observation: nowadays there are a significant number of voice assistants coupled with numerous tools promising hyper connectivity and boosted productivity. We therefore end up getting lost in all these opaque layers processing our personal data as well as in subscriptions that are often prohibitively expensive compared to the simplicity of the tasks that we want our electronic companion to carry out.

Today I decided to show you in the smallest details how I managed to design **Cristal** a voice assistant which can respond to all your wishes as long as you are ready to fiddle a minimum between the hardware and the software.

![Cristal Home Assistant|inline](https://romainmellaza.fr/img/cristal-home-assistant/pres2.jpg)

# The necessary equipment
![|inline](https://www.gotronic.fr/ori-module-nodemcu-esp32-28407.jpg)

* An [ESP32](https://www.amazon.fr/esp32-wroom/s?k=esp32+wroom) will be the microcontroller of our project! We will take full advantage of its WiFi capacity but also of its integrated ADCs.
![|inline](https://www.az-delivery.de/cdn/shop/products/13-zoll-oled-i2c-128-x-64-pixel-display-kompatibel-mit-arduino-und-raspberry-pi-466478.jpg?v=1679397952&width=1200)

* An [OLED screen (128x64) using the SH1106 chip](https://www.az-delivery.de/en/products/1-3zoll-i2c-oled-display), it will be the main means of feedback with the user.
![|inline](https://www.electronicwings.com/storage/PlatformSection/TopicContent/452/description/MicroSD.jpg)

* A [MicroSD Card Module](https://www.amazon.fr/esp32-sd/s?k=esp32+sd) as well as a microSD card with the smallest capacity you have, in fact it will be useful to us only to temporarily store the audio file recorded by the microphone as well as the secret identifiers specific to your assistant, so it only takes a few kilobytes , but if you have personal upgrades requiring storage then judge the card's capacity accordingly. **⚠️ IMPORTANT NOTE : the card must be formatted in [FAT32 format](https://support.microsoft.com/fr-fr/topic/comment-convertir-un-lecteur-en-fat32-%C3%A0-l-aide-du-convertisseur-de-lecteur-5f751b9d-60a2-01bc-4079-2f536b876cc3)**

![©Osoyoo|inline](https://osoyoo.com/wp-content/uploads/2018/09/hc-sr04.png)

* An [Ultrasonic Sensor](https://www.amazon.com/ultrasonic-sensor/s?k=ultrasonic+sensor), **HC-SR04** is the safe bet.
![|inline](https://www.az-delivery.de/cdn/shop/products/max9814-mikrofon-964239.jpg?v=1679402420&width=1200)

* A microphone using the i2s protocol, personally I use the [MAX9814](https://www.az-delivery.de/fr/products/max9814-mikrofon) which is widespread in the field of microelectronics in particular because it carries a high quality amplifier with automatic gain control (AGC) and low noise microphone polarization.
![|inline](https://m.media-amazon.com/images/I/614vPNmpmuL._AC_UF894,1000_QL80_.jpg)

* LED's of the color you want. *(the best is that it matches the color of your case)*
![|inline](https://m.media-amazon.com/images/I/61G3+cfJHwL._SL1000_.jpg)

* A [push button](https://www.amazon.fr/s?k=push+button&__mk_fr_FR=%C3%85M%C3%85%C5%BD%C3%95%C3%91&ref=nb_sb_noss). 

# A small server
Unfortunately, although the esp32 is a true marvel due to the extent of its capabilities, certain actions are either not possible, or possible but within a period of time which makes use uncomfortable and not smooth.

This is the case for voice recognition for example, which is therefore central to our project, which is why it is necessary to first record the audio file before transmitting it to a more powerful device so that the latter achieves recognition. But be careful by "more powerful" I don't mean a server with 32GB of ram and a premium CPU, no it's quite the opposite! You can either rent the smallest server configuration from a host, or use a Raspberry Pi at home.
![|inline](https://m.media-amazon.com/images/I/61K2IaK2b9L._AC_UF1000,1000_QL80_.jpg)

In my case for example, I rent a server thanks to DigitalOcean, I selected the lowest possible configuration with only 1GB of Ram and an inefficient Intel processor. But it is more than sufficient as you can see in the graphs below, in terms of the memory or processor usage percentages with actions initiated by my custom assistant.

![Screenshot of data measured on the server I used for this project](https://romainmellaza.fr/img/cristal-home-assistant/digital-ocean.png)

**If you would like to see in more detail how to set up your Linux server for the voice assistant, [click here]().**

# 3D models for those who want/can print them...
You can print the four parts of the project, here are the 3d files, feel free to modify them as you wish! *(namely I printed it with my Ender-3 V3 SE)*

![|inline](https://romainmellaza.fr/img/cristal-home-assistant/printing-1.jpg)

* [The button to activate voice recording.](https://github.com/4strium/Cristal-Home-Assistant/blob/main/models/Bouton-Cristal-AI.3mf)
* [The head of the robot with its two antennas.](https://github.com/4strium/Cristal-Home-Assistant/blob/main/models/Head%20cristal.3mf)
* [The body that will carry all the electronics.](https://github.com/4strium/Cristal-Home-Assistant/blob/main/models/body.3mf) 
* [The hood to make the link between the head and the body.](https://github.com/4strium/Cristal-Home-Assistant/blob/main/models/capuchon.3mf)

# Wiring 

Make the connections follow this:

### Micro SD Card Module :
* 3.3 V
* MISO : GPIO 19
* CLK : GPIO 18
* MOSI : GPIO 23
* CS : GPIO 5
* GND

### Ultrasonic sensor :
* VCC : 5V
* Trig : GPIO 15
* Echo : GPIO 2
* GND

### OLED Display :
* VDD : 5V
* GND
* SCK : GPIO 22
* SDA : GPIO 27

### Blue LED'S :
* GPIO 12
* GND 

### Push Button :
* 3.3 V
* GPIO 4
* GND

### Microphone MAX9814 :
* VDD : 3.3 V
* OUT : GPIO 35 (ADC1_CHANNEL_7)
* GND

# Functionalities :

* If you want to see how to display live weather on screen via I2C, [click here]().

* If you want to see how to display live date and time based on GPS coordinates (to get timezone) on an I2C screen, [click here]().

* If you want to see how to record sound on microSD card via MAX9814 microphone, [click here]().

* If you want to see how to keep your [API](https://en.wikipedia.org/wiki/API) identifiers secret for this ultra-connected project, [click here]().

# Draw eyes expressions on an OLED screen

Here is a class for creating facial expressions on a 128x64 screen using geometry from the [u8g2lib](https://github.com/olikraus/u8g2) library.

```cpp
class Eyes {
private :
  int x1, x2, y, width, height;
public :
  int step;
  void initialize(){
    x1 = 8;
    x2 = 70;
    y = 24;
    height = 14;
    width = 50;
    step = 0;
  }

  void det_eyes_in(){
    for (int brightness = 0; brightness < 256; brightness+=15){
      u8g2.clearBuffer();
      u8g2.setContrast(brightness);
      u8g2.drawRBox(x1, y, width, height, 7);
      u8g2.drawRBox(x2, y, width, height, 7);
      u8g2.sendBuffer();
    }
    step = 1;
  }

  void det_eyes_out(){
    for (int brightness = 255; brightness >= 0; brightness-=15){
      u8g2.clearBuffer();
      u8g2.setContrast(brightness);
      u8g2.drawRBox(x1, y, width, height, 7);
      u8g2.drawRBox(x2, y, width, height, 7);
      u8g2.sendBuffer();
    }
    step = 0;
  }

  void clign_in(){
    if (step == 2){ 
      for (int i = 0; i < 12; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        y += 1;
        height -= 2;
      };
      step = 1;
    }
  } 

  void clign_out(){
    if (step == 1){
      for (int i = 0; i < 12; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        y -= 1;
        height += 2;
      };
      step = 2;
    }
  }

  void round_in(){
    if (step == 2){
      for (int i = 0; i < 16; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        y += 1;
        height -= 1;
        x1 += 1;
        x2 += 1;
        width -= 2;
      };
      step = 3;
    }
  }

  void round_out(){
    if (step == 3){
      for (int i = 0; i < 16; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        y -= 1;
        height += 1;
        x1 -= 1;
        x2 -= 1;
        width += 2;
      };
      step = 2;
      digitalWrite(BLUE_LED, LOW);
    }
  }

  void look_right(){
    if (step == 3){
      for (int i = 0; i < 14; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 += 4;
        x2 += 1;
      }
      delay(1000);
      for (int i = 0; i < 14; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 -= 4;
        x2 -= 1;
      }
    }
  }

  void look_left(){
    if (step == 3){
      for (int i = 0; i < 14; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 -= 1;
        x2 -= 4;
      }
      delay(1000);
      for (int i = 0; i < 14; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 += 1;
        x2 += 4;
      }
    }
  }

  void look_up(){
    if (step == 3){ 
      for (int i = 0; i < 20; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 += 1;
        x2 -= 1;
        y -= 1;
      }
      delay(1000);
      for (int i = 0; i < 20; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 -= 1;
        x2 += 1;
        y += 1;
      }
    }
  }

  void look_down(){
    if (step == 3){
      for (int i = 0; i < 20; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 += 1;
        x2 -= 1;
        y += 1;
      }
      delay(1000);
      for (int i = 0; i < 20; i++){
        u8g2.clearBuffer();
        u8g2.drawRBox(x1, y, width, height, 7);
        u8g2.drawRBox(x2, y, width, height, 7);
        u8g2.sendBuffer();
        x1 -= 1;
        x2 += 1;
        y -= 1;
      }
    }
  }
};
```

# View and manage a timer on an OLED screen

Here is a class for creating a timer on a 128x64 screen using the [u8g2lib](https://github.com/olikraus/u8g2) library. To initiate a timer, simply call Timer(`<number_of_seconds>`), for example `Timer(600)` initiates a timer of 600 seconds/10 minutes.

```cpp
// 'sablier', 64x64px
const unsigned char epd_bitmap_sablier_top [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 
	0x00, 0xc0, 0x1f, 0x00, 0x00, 0xf8, 0x03, 0x00, 0x00, 0xc0, 0x1f, 0x00, 0x00, 0xf8, 0x03, 0x00, 
	0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00, 
	0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x80, 0x3f, 0x00, 0x00, 0xfc, 0x01, 0x00, 
	0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x7f, 0x00, 0x00, 0xfe, 0x00, 0x00, 
	0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x00, 0x00, 0x7f, 0x00, 0x00, 
	0x00, 0x00, 0xfc, 0x01, 0x80, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x03, 0xc0, 0x3f, 0x00, 0x00, 
	0x00, 0x00, 0xf8, 0x07, 0xe0, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x0f, 0xf0, 0x0f, 0x00, 0x00, 
	0x00, 0x00, 0xe0, 0x1f, 0xf8, 0x07, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x3f, 0xfc, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x7f, 0xfe, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x07, 0x00, 0x00, 
	0x00, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x1f, 0x00, 0x00, 
	0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 
	0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 
	0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'sablier', 64x64px
const unsigned char epd_bitmap_sablier_right [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 
	0xc0, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x07, 
	0xe0, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0x07, 0xe0, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x07, 
	0xe0, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0x01, 0x80, 0xff, 0xc1, 0x07, 
	0xe0, 0xff, 0xff, 0x03, 0xc0, 0x7f, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0x07, 0xe0, 0x1f, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0x0f, 0xf0, 0x0f, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0x1f, 0xf8, 0x07, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0x7f, 0xfe, 0x03, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x01, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0xff, 0x1f, 0x00, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0xff, 0x3f, 0x00, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0xff, 0x7f, 0x00, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0xff, 0xff, 0x00, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0xff, 0xff, 0x01, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0x7f, 0xfe, 0x03, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0x1f, 0xf8, 0x07, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0x0f, 0xf0, 0x0f, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0x07, 0xe0, 0x1f, 0xc0, 0x07, 0xe0, 0xff, 0xff, 0x03, 0xc0, 0x7f, 0xc0, 0x07, 
	0xe0, 0xff, 0xff, 0x01, 0x80, 0xff, 0xc1, 0x07, 0xe0, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x07, 
	0xe0, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x07, 0xe0, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0x07, 
	0xe0, 0xff, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x07, 0xc0, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0x03, 
	0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'sablier', 64x64px
const unsigned char epd_bitmap_sablier_bottom [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 
	0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 
	0x00, 0x00, 0xfe, 0xff, 0xff, 0x7f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 
	0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0xf8, 0xff, 0xff, 0x1f, 0x00, 0x00, 
	0x00, 0x00, 0xf0, 0xff, 0xff, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xe0, 0xff, 0xff, 0x07, 0x00, 0x00, 
	0x00, 0x00, 0xc0, 0xff, 0xff, 0x03, 0x00, 0x00, 0x00, 0x00, 0x80, 0xff, 0xff, 0x01, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf8, 0x1f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x3f, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xfe, 0x7f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7f, 0xfe, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x80, 0x3f, 0xfc, 0x01, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x1f, 0xf8, 0x03, 0x00, 0x00, 
	0x00, 0x00, 0xe0, 0x0f, 0xf0, 0x07, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x03, 0xc0, 0x0f, 0x00, 0x00, 
	0x00, 0x00, 0xf8, 0x01, 0x80, 0x1f, 0x00, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 
	0x00, 0x00, 0xfc, 0x00, 0x00, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x7e, 0x00, 0x00, 0x7e, 0x00, 0x00, 
	0x00, 0x00, 0x3e, 0x00, 0x00, 0x7c, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x00, 0xfc, 0x00, 0x00, 
	0x00, 0x00, 0x1f, 0x00, 0x00, 0xf8, 0x00, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00, 
	0x00, 0x80, 0x1f, 0x00, 0x00, 0xf8, 0x01, 0x00, 0x00, 0x80, 0x1f, 0x00, 0x00, 0xf0, 0x01, 0x00, 
	0x00, 0x80, 0x0f, 0x00, 0x00, 0xf0, 0x01, 0x00, 0x00, 0xc0, 0x0f, 0x00, 0x00, 0xf0, 0x03, 0x00, 
	0x00, 0xc0, 0xff, 0xff, 0xff, 0xff, 0x03, 0x00, 0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 
	0x00, 0x80, 0xff, 0xff, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0xfc, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

// 'sablier', 64x64px
const unsigned char epd_bitmap_sablier_left [] PROGMEM = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 
	0xc0, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0x03, 0xe0, 0xff, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x07, 
	0xe0, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0x07, 0xe0, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x07, 
	0xe0, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x07, 0xe0, 0x83, 0xff, 0x01, 0x80, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0xfe, 0x03, 0xc0, 0xff, 0xff, 0x07, 0xe0, 0x03, 0xf8, 0x07, 0xe0, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0xf0, 0x0f, 0xf0, 0xff, 0xff, 0x07, 0xe0, 0x03, 0xe0, 0x1f, 0xf8, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0xc0, 0x7f, 0xfe, 0xff, 0xff, 0x07, 0xe0, 0x03, 0x80, 0xff, 0xff, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff, 0x07, 0xe0, 0x03, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x07, 0xe0, 0x03, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0x00, 0xf8, 0xff, 0xff, 0xff, 0x07, 0xe0, 0x03, 0x00, 0xfc, 0xff, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0x00, 0xfe, 0xff, 0xff, 0xff, 0x07, 0xe0, 0x03, 0x00, 0xff, 0xff, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0x80, 0xff, 0xff, 0xff, 0xff, 0x07, 0xe0, 0x03, 0xc0, 0x7f, 0xfe, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0xe0, 0x1f, 0xf8, 0xff, 0xff, 0x07, 0xe0, 0x03, 0xf0, 0x0f, 0xf0, 0xff, 0xff, 0x07, 
	0xe0, 0x03, 0xf8, 0x07, 0xe0, 0xff, 0xff, 0x07, 0xe0, 0x03, 0xfe, 0x03, 0xc0, 0xff, 0xff, 0x07, 
	0xe0, 0x83, 0xff, 0x01, 0x80, 0xff, 0xff, 0x07, 0xe0, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x07, 
	0xe0, 0xff, 0x7f, 0x00, 0x00, 0xfe, 0xff, 0x07, 0xe0, 0xff, 0x3f, 0x00, 0x00, 0xfc, 0xff, 0x07, 
	0xe0, 0xff, 0x0f, 0x00, 0x00, 0xf0, 0xff, 0x07, 0xc0, 0xff, 0x03, 0x00, 0x00, 0xc0, 0xff, 0x03, 
	0xc0, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x03, 0x00, 0x0f, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

class Timer {
  private :
    int requ_time, minutes, secondes;
    bool already_act;

    void set_normal_time(void){
      if (requ_time >= 60){
        minutes = requ_time / 60;
        secondes = requ_time - (minutes*60);
      }
      else{
        minutes = 0;
        secondes = requ_time;
      }
    }

    void start_timer(void){
      if (!already_act){
        already_act = true;
        char buffer_time_curr[5];
        while (requ_time > 0){
          u8g2.clearBuffer();
          u8g2.setFont(u8g2_font_helvB18_te);
          u8g2.setFontDirection(2);
          u8g2.enableUTF8Print();
          u8g2.drawUTF8(65,40,"Timer");

          u8g2.setFont(u8g2_font_logisoso24_tr);

          snprintf(buffer_time_curr, sizeof(buffer_time_curr), "%i:%02i", minutes, secondes);
          u8g2.drawUTF8(65,5,buffer_time_curr);

          u8g2.setBitmapMode(1);
          if (requ_time % 4 == 0){
            u8g2.drawXBM(66, 2, 64, 64, epd_bitmap_sablier_top);
          }
          else if (requ_time % 4 == 1){
            u8g2.drawXBM(66, 2, 64, 64, epd_bitmap_sablier_left);
          }
          else if (requ_time % 4 == 2){
            u8g2.drawXBM(66, 2, 64, 64, epd_bitmap_sablier_bottom);
          }
          else {
            u8g2.drawXBM(70, 2, 64, 64, epd_bitmap_sablier_right);
          }

          requ_time--;
          u8g2.sendBuffer();
          set_normal_time();
          delay(1000);
        }       
      }
    }
  public :
    Timer(int inp_t){
      requ_time = inp_t;
      already_act = false;
      set_normal_time();
      start_timer();
    }
};
```

# Setup & Loop

In Arduino programming, the `setup()` and `loop()` functions are fundamental to every sketch (a program written for Arduino). They define the basic structure and flow of your Arduino code. The `setup()` function is used to initialize variables, pin modes, start using libraries, and set up any other required state or configurations for your Arduino program. It is executed only once when the Arduino board is powered on or reset. The `loop()` function is where the main logic of the Arduino program is executed. It runs continuously in a loop after the setup() function has completed.

So that you have a clear idea, here is what the setup function of the program looks like inside the “Cristal” wizard :

```cpp
Eyes e1;

void setup(void) {
  pinMode(35,INPUT);
  Serial.begin(9600);
  Wire.begin(I2C_SDA, I2C_SCL);
  u8g2.begin();
  e1.initialize();

  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);

  pinMode(BLUE_LED, OUTPUT);

  pinMode(BTN_PIN, INPUT);

  const char* ssid = get_secret(0);
  const char* password = get_secret(1);
  API_key = get_secret(2);
  Model_Id = get_secret(3);
  Device_Id = get_secret(4);

  // Utilisation des valeurs
  Serial.println("SSID: " + String(ssid));
  Serial.println("Password: " + String(password));

  Serial.println("Connexion au réseau WiFi...");
  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(1000);
    Serial.println("Connexion en cours...");
  }

  Serial.println("Connecté au réseau WiFi !");

}
```